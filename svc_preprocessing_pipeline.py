#!/usr/bin/env python3
"""
Apple M1 Singing Voice Conversion (SVC) Preprocessing Pipeline
==============================================================

Implements the cascaded preprocessing workflow described in the research report:
1. Stage 1: Instrument separation using BS-Roformer
2. Stage 2: Dereverberation using Mel-Band Roformer De-Reverb-Echo V2

This pipeline converts raw audio files with background music and reverb into
clean "dry" vocals suitable for high-fidelity RVC training.
"""

import argparse
import logging
import os
import subprocess
import sys
from pathlib import Path
from typing import Optional, Tuple

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)
logger = logging.getLogger(__name__)

class SVCPreprocessingPipeline:
    """
    Apple M1 optimized SVC preprocessing pipeline.
    
    Implements the two-stage cascaded processing:
    - Stage 1: Vocal separation from instruments
    - Stage 2: Acoustic dereverberation for "dry" signal
    """
    
    def __init__(self, models_dir: str = "./models", conda_env: str = "rvc-singing"):
        self.models_dir = Path(models_dir)
        self.conda_env = conda_env
        
        # Model specifications from research report
        self.bs_roformer_model = "model_bs_roformer_ep_317_sdr_12.9755.ckpt"
        self.dereverb_model = "dereverb-echo_mel_band_roformer_sdr_13.4843_v2.ckpt"
        
        # Verify models exist
        self._verify_models()
    
    def _verify_models(self) -> None:
        """Verify that required models are available."""
        bs_roformer_path = self.models_dir / self.bs_roformer_model
        dereverb_path = self.models_dir / self.dereverb_model
        
        if not bs_roformer_path.exists():
            raise FileNotFoundError(
                f"BS-Roformer model not found: {bs_roformer_path}\n"
                f"Please ensure models are downloaded to {self.models_dir}"
            )
        
        if not dereverb_path.exists():
            raise FileNotFoundError(
                f"De-reverb model not found: {dereverb_path}\n"
                f"Please ensure models are downloaded to {self.models_dir}"
            )
        
        logger.info("‚úÖ All required models verified")
    
    def _run_audio_separator(self, 
                           input_file: Path, 
                           model: str, 
                           output_dir: Path, 
                           normalization: float = 0.9) -> Tuple[bool, str]:
        """
        Run audio-separator with specified model.
        
        Args:
            input_file: Input audio file path
            model: Model filename to use
            output_dir: Output directory
            normalization: Normalization factor (0.9 as per research)
            
        Returns:
            Tuple of (success, error_message)
        """
        try:
            # Construct command
            cmd = [
                "audio-separator",
                str(input_file),
                "--model_filename", model,
                "--model_file_dir", str(self.models_dir),
                "--output_dir", str(output_dir),
                "--output_format", "WAV",
                "--normalization", str(normalization)
            ]
            
            logger.info(f"Running: {' '.join(cmd)}")
            
            # Run within conda environment
            conda_cmd = f"source ~/miniconda3/bin/activate {self.conda_env} && {' '.join(cmd)}"
            
            result = subprocess.run(
                conda_cmd,
                shell=True,
                capture_output=True,
                text=True,
                executable="/bin/zsh"
            )
            
            if result.returncode == 0:
                logger.info("‚úÖ Audio separation completed successfully")
                return True, ""
            else:
                error_msg = f"Audio separator failed: {result.stderr}"
                logger.error(error_msg)
                return False, error_msg
                
        except Exception as e:
            error_msg = f"Exception during audio separation: {str(e)}"
            logger.error(error_msg)
            return False, error_msg
    
    def _find_output_file(self, output_dir: Path, input_filename: str, target_suffix: str) -> Optional[Path]:
        """
        Find the output file generated by audio-separator.
        
        Args:
            output_dir: Directory to search
            input_filename: Original input filename
            target_suffix: Expected suffix (e.g., "(Vocals)", "(Dry)")
            
        Returns:
            Path to found file or None
        """
        # Remove extension from input filename
        base_name = Path(input_filename).stem
        
        # Look for files containing the target suffix
        for file_path in output_dir.glob("*.wav"):
            if base_name in file_path.name and target_suffix in file_path.name:
                logger.info(f"Found output file: {file_path}")
                return file_path
        
        # If not found, list all files for debugging
        logger.warning(f"Could not find file with suffix '{target_suffix}' in {output_dir}")
        logger.warning("Available files:")
        for file_path in output_dir.glob("*"):
            logger.warning(f"  - {file_path.name}")
        
        return None
    
    def process_file(self, 
                    input_file: str, 
                    output_dir: str = "processed_vocals") -> Tuple[bool, Optional[Path]]:
        """
        Process a single audio file through the complete pipeline.
        
        Args:
            input_file: Path to input audio file
            output_dir: Base output directory
            
        Returns:
            Tuple of (success, final_dry_vocals_path)
        """
        input_path = Path(input_file)
        if not input_path.exists():
            logger.error(f"Input file not found: {input_path}")
            return False, None
        
        logger.info(f"üéµ Processing: {input_path.name}")
        logger.info("=" * 60)
        
        # Create output directories
        base_output_dir = Path(output_dir)
        stage1_dir = base_output_dir / "stage1_vocal_separation"
        stage2_dir = base_output_dir / "stage2_dereverberation"
        
        for dir_path in [stage1_dir, stage2_dir]:
            dir_path.mkdir(parents=True, exist_ok=True)
        
        # Stage 1: Vocal separation using BS-Roformer
        logger.info("üé§ Stage 1: Separating vocals from instruments...")
        success, error = self._run_audio_separator(
            input_path, 
            self.bs_roformer_model, 
            stage1_dir
        )
        
        if not success:
            logger.error(f"Stage 1 failed: {error}")
            return False, None
        
        # Find the vocals output from stage 1
        vocals_file = self._find_output_file(stage1_dir, input_path.name, "(Vocals)")
        if not vocals_file:
            logger.error("Stage 1: Could not find vocals output file")
            return False, None
        
        # Stage 2: Dereverberation using Mel-Band Roformer
        logger.info("üè† Stage 2: Removing reverb and echo for dry signal...")
        success, error = self._run_audio_separator(
            vocals_file,
            self.dereverb_model,
            stage2_dir
        )
        
        if not success:
            logger.error(f"Stage 2 failed: {error}")
            return False, None
        
        # Find the dry output from stage 2
        dry_vocals_file = self._find_output_file(stage2_dir, vocals_file.name, "(Dry)")
        if not dry_vocals_file:
            logger.error("Stage 2: Could not find dry vocals output file")
            return False, None
        
        # Success!
        logger.info("=" * 60)
        logger.info("üéâ Pipeline completed successfully!")
        logger.info(f"‚ú® Final dry vocals: {dry_vocals_file}")
        logger.info(f"üìÅ All outputs in: {base_output_dir}")
        
        return True, dry_vocals_file
    
    def process_batch(self, input_dir: str, output_dir: str = "processed_vocals") -> None:
        """
        Process multiple audio files in batch.
        
        Args:
            input_dir: Directory containing input audio files
            output_dir: Base output directory
        """
        input_path = Path(input_dir)
        if not input_path.exists():
            logger.error(f"Input directory not found: {input_path}")
            return
        
        # Supported audio formats
        audio_extensions = ['.wav', '.mp3', '.flac', '.m4a', '.aac']
        
        # Find all audio files
        audio_files = []
        for ext in audio_extensions:
            audio_files.extend(input_path.glob(f"*{ext}"))
            audio_files.extend(input_path.glob(f"*{ext.upper()}"))
        
        if not audio_files:
            logger.error(f"No audio files found in {input_path}")
            return
        
        logger.info(f"Found {len(audio_files)} audio files to process")
        
        successful = 0
        failed = 0
        
        for audio_file in audio_files:
            logger.info(f"\nüéµ Processing {successful + failed + 1}/{len(audio_files)}: {audio_file.name}")
            
            success, _ = self.process_file(str(audio_file), output_dir)
            
            if success:
                successful += 1
            else:
                failed += 1
        
        logger.info("\n" + "=" * 60)
        logger.info("üìä Batch Processing Summary")
        logger.info(f"‚úÖ Successful: {successful}")
        logger.info(f"‚ùå Failed: {failed}")
        logger.info(f"üìÅ Output directory: {output_dir}")


def main():
    """Main CLI interface."""
    parser = argparse.ArgumentParser(
        description="Apple M1 SVC Preprocessing Pipeline",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Process single file
  python svc_preprocessing_pipeline.py input_song.wav
  
  # Process with custom output directory
  python svc_preprocessing_pipeline.py input_song.wav --output /path/to/output
  
  # Batch process directory
  python svc_preprocessing_pipeline.py --batch /path/to/audio_files
  
  # Use custom models directory
  python svc_preprocessing_pipeline.py input_song.wav --models-dir /path/to/models
        """
    )
    
    # Input options
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument("input_file", nargs='?', help="Input audio file")
    group.add_argument("--batch", help="Process all audio files in directory")
    
    # Output options
    parser.add_argument("--output", "-o", default="processed_vocals",
                       help="Output directory (default: processed_vocals)")
    
    # Configuration options
    parser.add_argument("--models-dir", default="./models",
                       help="Models directory (default: ./models)")
    parser.add_argument("--conda-env", default="rvc-singing",
                       help="Conda environment name (default: rvc-singing)")
    
    args = parser.parse_args()
    
    try:
        # Initialize pipeline
        pipeline = SVCPreprocessingPipeline(args.models_dir, args.conda_env)
        
        if args.batch:
            # Batch processing
            pipeline.process_batch(args.batch, args.output)
        else:
            # Single file processing
            success, dry_file = pipeline.process_file(args.input_file, args.output)
            if not success:
                sys.exit(1)
    
    except KeyboardInterrupt:
        logger.info("\n‚ö†Ô∏è Processing interrupted by user")
        sys.exit(1)
    except Exception as e:
        logger.error(f"‚ùå Fatal error: {str(e)}")
        sys.exit(1)


if __name__ == "__main__":
    main()